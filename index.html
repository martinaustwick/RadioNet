<!DOCTYPE html>
<meta charset="utf-8">
<style>
.link {
  stroke: #000;
}
.node {
  stroke: #fff;
}


/*.node text {
  pointer-events: none;
  font: 10px sans-serif;
}*/

</style>
<body>
<script src="//d3js.org/d3.v4.min.js"></script>
<script>
var width = 960,
    height = 500;
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    //.style("background-color", "black")
    ;
// var force = d3.layout.force()
//     .size([width, height]);





var nodesByName = {};
var links = [];

//d3.csv("graph.csv", function(error, links) {

//add encompassing group for the zoom 
var g = svg.append("g")
    .attr("class", "everything");

d3.csv("data/producers_mod.csv", function(error, reccs) {
  if (error) throw error;

  //console.log(links);

  

  reccs.forEach(function(recc) {
    //the method removes redundancy
    //link.source = nodeByName(link.source);
    //link.target = nodeByName(link.target);

    //currently bypassing this logic
    var noTarget = false;
    if(recc.target.length>0) noTarget = false;
    if(recc.recomends_2.length>0) noTarget = false;
    if(recc.recomends_3.length>0) noTarget = false;
    if(recc.recomends_4.length>0) noTarget = false;
    if(recc.recomends_5.length>0) noTarget = false;

    if(!noTarget)
    {
      var s= nodeByNode(recc, recc.source);
      //console.log(s);
      var t = nodeByName(recc.target);    
      
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_2);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_3);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_4);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_5);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
    }
    //link.id = nodeByName(link.id);
    //link.broadcaster_id = nodeByName(link.broadcaster_id);
  });

  //console.log(links);
  // Extract the array of nodes from the map by name.
  //key/value pair is the context?
  // var nodes = d3.values(nodesByName);
  // console.log(nodes);
  // // Create the link lines.
  // var link = svg.selectAll(".link")
  //     .data(links)
  //   .enter().append("line")
  //     .attr("class", "link")
  //     .style("stroke", function(d){
  //       if(d.source.name[0]=='P') return 'black';
  //       else return 'blue';
  //     });
  // // Create the node circles.
  // var node = svg.selectAll(".node")
  //     .data(nodes)
  //   .enter().append("g")
  //     .attr("class", "node")
  //     .call(force.drag);

  // node.append("circle").attr("r", 4.5)
  //   .attr('fill', function(d)
  //     {
  //       if(d.name[0]=='P') return 'black';
  //       else return 'blue';
  //     });

  //  node.append("text")
  //     //.attr("dx", 12)
  //     // .attr("dy", ".35em")
  //     .attr('stroke', 'black')
  //     .text(function(d) { return d.name });

  // // Start the force layout.
  // force
  //     .nodes(nodes)
  //     .links(links)
  //     .on("tick", tick)
  //     .linkDistance(20)
  //     .charge(-50)
  //     .start();

  // function tick() {
  //   link.attr("x1", function(d) { return d.source.x; })
  //       .attr("y1", function(d) { return d.source.y; })
  //       .attr("x2", function(d) { return d.target.x; })
  //       .attr("y2", function(d) { return d.target.y; });
  //   node.attr("cx", function(d) { return d.x; })
  //       .attr("cy", function(d) { return d.y; });

  //   node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  // }
  //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  

  function nodeByName(name) {
    return nodesByName[name] || (nodesByName[name] = {name: name});
  }



  function nodeByNode(node, name) {
    //console.log(nodesByName[name]);
    if(!nodesByName[name]) nodesByName[name] = {name: name, node: node};
    return nodesByName[name];
    
  }
});












d3.csv("data/audio_pieces_mod.csv", function(error, reccs) {
  if (error) throw error;

  //console.log(links);

  reccs.forEach(function(recc) {
    //the method removes redundancy
    //link.source = nodeByName(link.source);
    //link.target = nodeByName(link.target);

    var noTarget = false;
    if(recc.producer_id.length>0) noTarget = false;
    if(recc.producer_2_id.length>0) noTarget = false;
    if(recc.producer_3_id.length>0) noTarget = false;
    
    if(!noTarget)
    {
      //var s= nodeByName(recc.id);
      var s= nodeByNode2(recc, recc.id);
      console.log(s);
      var t = nodeByName(recc.producer_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:2});

      t = nodeByName(recc.producer_2_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:2});

      t = nodeByName(recc.producer_3_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:2});
    }

  });

  //console.log(links);
  // Extract the array of nodes from the map by name.
  //key/value pair is the context?
  var nodes = d3.values(nodesByName);
  //console.log(nodes);
  // Create the link lines.
  var link = //svg.selectAll(".link")
      g.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke", function(d){
        if(d.source.name[0]=='P') return 'black';
        else return 'red';
      })
      .style("stroke-width",function(d)
      {
        if(d.source.name[0]=='P') return 1;
        else return 4;

      })
      ;
  // Create the node circles.
  var node = //svg.selectAll(".node")
      g.append("g")
        .attr("class", "nodes") 
        .selectAll("circle")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node");
      //.call(force.drag);

  node.append("circle")
    .attr("r", function(d)
      {
        if(d.name[0]=='P') return 8;
        else return 4;
      })
    .attr('fill', function(d)
      {
        if(d.name[0]=='P') return 'black';
        else return '#FF1111AA';
      })
    .attr('stroke', function(d)
      {
        if(d.name[0]=='P') return 'black';
        else return 'black';
      })
    .on("click", function(d){
        console.log(d);
      }
      );

   node.append("text")
      .style("font-size", 20)
      .attr("dx", 8)
      .attr('stroke', 'black')
      .text(function(d) { 
         if(d.node) return d.node.name
         else return d.name
      });

  // Start the force layout.
  // force
  //     .nodes(nodes)
  //     .links(links)
  //     .on("tick", tick)
  //     .linkDistance(5)
  //     .charge(-60)
  //     .start()
  //     .linkStrength(function(link)
  //       {
  //         return link.weight;
  //       });

  //set up the simulation and add forces  
var simulation = d3.forceSimulation()
          .nodes(nodes);
                              
var link_force =  d3.forceLink(links)
                        .id(function(d) { return d.name; })
                        .distance(50)
                        .strength(function(d){return d.weight;})
                        ;            
         
var charge_force = d3.forceManyBody()
    .strength(-450); 
    
var center_force = d3.forceCenter(width / 2, height / 2);  


simulation
    .force("charge_force", charge_force)
    .force("center_force", center_force)
    .force("links",link_force)
    .force("x_force", d3.forceX(width/2).strength(0.03))
    .force("y_force", d3.forceY(height/2).strength(0.05))
    .alpha(0.9)
    .alphaDecay(0.001)
 ;

        
//add tick instructions: 
simulation.on("tick", tick );

  function tick() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  }
  //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  

  function nodeByName(name) {
    return nodesByName[name] || (nodesByName[name] = {name: name});
  }

  function nodeByNode2(node, name) {
    //console.log(nodesByName[name]);
    if(!nodesByName[name]) nodesByName[name] = {name: name, node:node};
    if(!nodesByName[name].node) nodesByName[name].node = node;
    //nodesByName[name] = {name: name, node:node};
    return nodesByName[name];
  }

  // function newNode(node, name)
  // {
  //   //console.log(nodesByName[name]);
  //   return {name: name, node:node};    
  // }

  //add drag capabilities  
var drag_handler = d3.drag()
  .on("start", drag_start)
  .on("drag", drag_drag)
  .on("end", drag_end); 
  
drag_handler(node);


//add zoom capabilities 
var zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);

zoom_handler(svg);     

/** Functions **/


//Drag functions 
//d is the node 
function drag_start(d) {
 if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

//make sure you can't drag the circle outside the box
function drag_drag(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function drag_end(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

//Zoom functions 
function zoom_actions(){
    g.attr("transform", d3.event.transform)
}







});


</script>