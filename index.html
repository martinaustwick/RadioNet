<!DOCTYPE html>
<meta charset="utf-8">
<style>
.link {
  stroke: #000;
}
.node {
  stroke: #fff;
}


/*.node text {
  pointer-events: none;
  font: 10px sans-serif;
}*/
</style>

<body>
<script type="text/javascript" src="d3.v4.min.js"></script>
<!--script src="https://d3js.org/d3.v4.min.js"></script-->
 <!--script type='text/javascript' src="./word_wrap.js"></script-->

<script>



var width = 960,
    height = 500;

    var deselectAlpha = '20';

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    //.style("background-color", "black")
    ;
// var force = d3.layout.force()
//     .size([width, height]);





var nodesByName = {};
var links = [];

//d3.csv("graph.csv", function(error, links) {

//add encompassing group for the zoom 


    //


var textWidth = 300;
var textHeight = 400;

// function wrap(text, width) {
//   text.each(function() {
//     var text = d3.select(this),
//         words = text.text().split(/\s+/).reverse(),
//         word,
//         line = [],
//         lineNumber = 0,
//         lineHeight = 1.1, // ems
//         y = text.attr("y"),
//         dy = parseFloat(text.attr("dy")),
//         tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
//     while (word = words.pop()) {
//       line.push(word);
//       tspan.text(line.join(" "));
//       if (tspan.node().getComputedTextLength() > width) {
//         line.pop();
//         tspan.text(line.join(" "));
//         line = [word];
//         tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
//       }
//     }
//   });
//   }



// var testText = ["Intro from Jeff Towne: We all know the experience - listening to the radio or watching TV, a loud commercial jumps out, sending you grabbing for the volume control. Or conversely, your favorite program is too quiet leading you to crank up the volume, even though you know louder levels will startle you as the next program starts. Variations in program levels have been a problem for public radio stations, and now the public radio world is attempting to even out this difference by implementing a new loudness standard. Adhering to this standard will soon be required when submitting programs to the Public Radio Satellite Systemâ€™s ContentDepot, PRX, and other organizations, and it's also just a good tool for making sure your mixes keep a steady level. Rob Byers tells us about the concept of Loudness, and how to use it to create better mixes that are both internally consistent and compatible with other programs in the public radio system."];
var testText = "RadioNet";

//courtesy Mike Bostock:
function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.1, // ems
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > (width-text.attr("dx"))) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").attr("dx", text.attr("dx")).text(word);
      }
    }
  });
}




    //


var g = svg.append("g")
    .attr("class", "everything")
    ;
d3.csv("data/producers_mod.csv", function(error, reccs) {
  if (error) throw error;

  //console.log(links);

  

  reccs.forEach(function(recc) {
    //the method removes redundancy
    //link.source = nodeByName(link.source);
    //link.target = nodeByName(link.target);

    //currently bypassing this logic
    var noTarget = false;
    if(recc.target.length>0) noTarget = false;
    if(recc.recomends_2.length>0) noTarget = false;
    if(recc.recomends_3.length>0) noTarget = false;
    if(recc.recomends_4.length>0) noTarget = false;
    if(recc.recomends_5.length>0) noTarget = false;

    if(!noTarget)
    {
      var s= nodeByNode(recc, recc.source);
      //console.log(s);
      var t = nodeByName(recc.target);    
      
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_2);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_3);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_4);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
      t = nodeByName(recc.recomends_5);
      if(t.name.length>0)links.push({source: s, target: t, weight:0.1});
    }
    //link.id = nodeByName(link.id);
    //link.broadcaster_id = nodeByName(link.broadcaster_id);
  });

  //console.log(links);
  // Extract the array of nodes from the map by name.
  //key/value pair is the context?
  // var nodes = d3.values(nodesByName);
  // console.log(nodes);
  // // Create the link lines.
  // var link = svg.selectAll(".link")
  //     .data(links)
  //   .enter().append("line")
  //     .attr("class", "link")
  //     .style("stroke", function(d){
  //       if(d.source.name[0]=='P') return 'black';
  //       else return 'blue';
  //     });
  // // Create the node circles.
  // var node = svg.selectAll(".node")
  //     .data(nodes)
  //   .enter().append("g")
  //     .attr("class", "node")
  //     .call(force.drag);

  // node.append("circle").attr("r", 4.5)
  //   .attr('fill', function(d)
  //     {
  //       if(d.name[0]=='P') return 'black';
  //       else return 'blue';
  //     });

  //  node.append("text")
  //     //.attr("dx", 12)
  //     // .attr("dy", ".35em")
  //     .attr('stroke', 'black')
  //     .text(function(d) { return d.name });

  // // Start the force layout.
  // force
  //     .nodes(nodes)
  //     .links(links)
  //     .on("tick", tick)
  //     .linkDistance(20)
  //     .charge(-50)
  //     .start();

  // function tick() {
  //   link.attr("x1", function(d) { return d.source.x; })
  //       .attr("y1", function(d) { return d.source.y; })
  //       .attr("x2", function(d) { return d.target.x; })
  //       .attr("y2", function(d) { return d.target.y; });
  //   node.attr("cx", function(d) { return d.x; })
  //       .attr("cy", function(d) { return d.y; });

  //   node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  // }
  //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  

  function nodeByName(name) {
    return nodesByName[name] || (nodesByName[name] = {name: name});
  }



  function nodeByNode(node, name) {
    //console.log(nodesByName[name]);
    if(!nodesByName[name]) nodesByName[name] = {name: name, node: node};
    return nodesByName[name];
    
  }
});






d3.csv("data/audio_pieces_mod.csv", function(error, reccs) {
  if (error) throw error;

  //console.log(links);

  reccs.forEach(function(recc) {
    //the method removes redundancy
    //link.source = nodeByName(link.source);
    //link.target = nodeByName(link.target);

    var noTarget = false;
    if(recc.producer_id.length>0) noTarget = false;
    if(recc.producer_2_id.length>0) noTarget = false;
    if(recc.producer_3_id.length>0) noTarget = false;
    
    if(!noTarget)
    {
      //var s= nodeByName(recc.id);
      var s= nodeByNode2(recc, recc.id);
      console.log(s);
      var t = nodeByName(recc.producer_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:1.5});

      t = nodeByName(recc.producer_2_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:1.5});

      t = nodeByName(recc.producer_3_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:1.5});
    }

  });

  //console.log(links);
  // Extract the array of nodes from the map by name.
  //key/value pair is the context?
  var nodes = d3.values(nodesByName);

  //console.log(nodes);
  // Create the link lines.
  var link = //svg.selectAll(".link")
      g.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke", function(d){
        if(d.source.name[0]=='P') return '#00000000';
        //else return '#FF111100'; 
        else return 'red';
      })
      .style("stroke-width",function(d)
      {
        if(d.source.name[0]=='P') return 1;
        else return 4;

      })
      ;
  // Create the node circles.
  var node = //svg.selectAll(".node")
      g.append("g")
        .attr("class", "nodes") 
        .selectAll("circle")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node");
      //.call(force.drag);

  svg.on("click", function(){
        onClick(-1);
      });

  node.append("circle")
    .attr("r", function(d)
      {
        if(d.name[0]=='P') return 20;
        else return 12;
      })
    .attr('fill', function(d)
      {
        if(d.name[0]=='P') return '#0011FF';
        else return '#FF1111';
      })
    .attr('stroke', "#FFFFFF55")
    .on("click", function(d){
        console.log("xircle");
        d3.event.stopPropagation();
        var origin = d.name;
        onClick(origin);
        //console.log(d3.event.target.id);
      }
      )
      ;

      

   node.append("text")
      .style("font-size", 20)
      .attr('stroke', '#00000000')
      .attr("dx", function(d){
        if(d.name[0]=='P') return 25;
        else return 15;
      })
      .attr("dy",function(d){
          if(d.name[0]=='P') return 5;
          else return 5;
      })
      .attr('fill', function(d){
          if(d.name[0]=='P') return '#0011FF';
          else return '#FF1111';
      })
      .text(function(d) { 
         if(d.node) return d.node.name
         else return d.name
      });

 
  // Start the force layout.
  // force
  //     .nodes(nodes)
  //     .links(links)
  //     .on("tick", tick)
  //     .linkDistance(5)
  //     .charge(-60)
  //     .start()
  //     .linkStrength(function(link)
  //       {
  //         return link.weight;
  //       });

  //set up the simulation and add forces  
var simulation = d3.forceSimulation()
          .nodes(nodes);
                              
var link_force =  d3.forceLink(links)
                        .id(function(d) { return d.name; })
                        .distance(40)
                        .strength(function(d){return d.weight;})
                        ;            
         
var charge_force = d3.forceManyBody()
    .strength(-450); 
    
var center_force = d3.forceCenter(width / 2, height / 2);  


simulation
    .force("charge_force", charge_force)
    .force("center_force", center_force)
    .force("links",link_force)
    .force("x_force", d3.forceX(width/2).strength(0.03))
    .force("y_force", d3.forceY(height/2).strength(0.05))
    .alpha(0.8)
    .alphaDecay(0.001)
 ;

        
//add tick instructions: 
simulation.on("tick", tick );

  function tick() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  }
  //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  
//>>>legend/labels
var legend = svg.append("g");

legend.append("rect")
    .attr("width", textWidth)
    .attr("height", 50)
    .attr("rx", 15)
    .attr("ry", 15)
    .attr("fill", "white")
    .attr("stroke", "black");

var legendText = legend.append("text")
    .data(testText)
    .attr("x", 40)
    .attr("y", 20)
    .attr("dx", 7)
    .attr("dy", 0)
    .text(testText)
    .call(wrap, textWidth);




  function nodeByName(name) {
    return nodesByName[name] || (nodesByName[name] = {name: name});
  }

  function nodeByNode2(node, name) {
    //console.log(nodesByName[name]);
    if(!nodesByName[name]) nodesByName[name] = {name: name, node:node};
    if(!nodesByName[name].node) nodesByName[name].node = node;
    //nodesByName[name] = {name: name, node:node};
    return nodesByName[name];
  }

  // function newNode(node, name)
  // {
  //   //console.log(nodesByName[name]);
  //   return {name: name, node:node};    
  // }

  //add drag capabilities  
var drag_handler = d3.drag()
  .on("start", drag_start)
  .on("drag", drag_drag)
  .on("end", drag_end); 
  
drag_handler(node);


//add zoom capabilities 
var zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);
zoom_handler(svg);
zoom_handler.scaleTo(svg, 0.5);

/** Functions **/


//Drag functions 
//d is the node 
function drag_start(d) {
 if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}

//make sure you can't drag the circle outside the box
function drag_drag(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function drag_end(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

//Zoom functions 
function zoom_actions(){
    g.attr("transform", d3.event.transform)
}

function onClick(or)
{
    var listOfNodes = [];

    legend.selectAll("rect").transition().attr("height", 50);
    legendText.text("RadioNet").data("RadioNet").call(wrap, textWidth);


    link
    .style('stroke', function(d){
        var alpha = '55';

        //make links to and from the clicked node more opaque
        if(d.source.name==or || d.target.name==or || or<0)
         {
          alpha="FF";
          listOfNodes.push(d.source.name);
          listOfNodes.push(d.target.name);
        }

        ///set text
        // if(d.source.name==or) {
        //   console.log(d.source.node);
        //   legendText.text(d.source.node.bio).data(d.source.node.bio).call(wrap, textWidth);
        // }

        //producer and audio colour if
        if(d.source.name[0]=='P'){
          if(d.source.name==or || d.target.name==or) alpha = "FF";
          else alpha = "00";
          return '#0011FF'+alpha;
        }
        else return '#FF1111'+alpha;
      })
    .style("stroke-width",function(d)
      {
        var w = 1;
        if(d.source.name[0]=='A') w+=3;
        if(d.source.name==or || d.target.name==or) w*=2
        return w;
      })
    ;

    node.each(function(d){
      if(d.name==or) {
         //console.log(d.node.description.length);
         var info = d.node.name + " :                            ";
        if(d.name[0]=='P' && d.node.bio.length>0) info = info + d.node.bio;
        if(d.name[0]=='A' && d.node.description.length>0) info = info + d.node.description;

        legendText.text(info).data(info).call(wrap, textWidth)

        legend.selectAll("rect").transition().attr("height", height);

        }
    });

   
    node.selectAll('circle')
    .attr('fill', function(d)
      {
        var alpha = deselectAlpha;

        if(d.name==or) alpha="FF";
        else if(listOfNodes.indexOf(d.name)>-1) alpha = 'CC';

        if(d.name[0]=='P') return '#0011FF'+alpha;
        else return '#FF1111'+alpha;

        // //set text
        // if(d.name==or) {
        //   console.log(d.name);
        // }
      })
    // .attr('stroke', function(d)
    //   {
    //     if(d.name==or) return "black";
    //     else return "#00000000";
    //   })
    ;

    node.selectAll('text')
    .attr('fill', function(d)
      {
        var alpha = deselectAlpha;
        if(d.name==or) alpha="FF";
        else if(listOfNodes.indexOf(d.name)>-1) alpha = 'CC';

        if(d.name[0]=='P') return '#0011FF'+alpha;
        else return '#FF1111'+alpha;

      });

    

}





});


</script>