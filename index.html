<!DOCTYPE html>
<meta charset="utf-8">
<style>
.link {
  stroke: #000;
}
.node {
  stroke: #fff;
}


/*.node text {
  pointer-events: none;
  font: 10px sans-serif;
}*/

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
var width = 960,
    height = 500;
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
var force = d3.layout.force()
    .size([width, height]);


var nodesByName = {};
var links = [];

//d3.csv("graph.csv", function(error, links) {

//add encompassing group for the zoom 
var g = svg.append("g")
    .attr("class", "everything");

d3.csv("data/producers_mod.csv", function(error, reccs) {
  if (error) throw error;

  //console.log(links);

  

  reccs.forEach(function(recc) {
    //the method removes redundancy
    //link.source = nodeByName(link.source);
    //link.target = nodeByName(link.target);
    var noTarget = true;
    if(recc.target.length>0) noTarget = false;
    if(recc.recomends_2.length>0) noTarget = false;
    if(recc.recomends_3.length>0) noTarget = false;
    if(recc.recomends_4.length>0) noTarget = false;
    if(recc.recomends_5.length>0) noTarget = false;

    if(!noTarget)
    {
      var s= nodeByName(recc.source);
      var t = nodeByName(recc.target);    
      
      if(t.name.length>0)links.push({source: s, target: t, weight:10});
      t = nodeByName(recc.recomends_2);
      if(t.name.length>0)links.push({source: s, target: t, weight:10});
      t = nodeByName(recc.recomends_3);
      if(t.name.length>0)links.push({source: s, target: t, weight:10});
      t = nodeByName(recc.recomends_4);
      if(t.name.length>0)links.push({source: s, target: t, weight:10});
      t = nodeByName(recc.recomends_5);
      if(t.name.length>0)links.push({source: s, target: t, weight:10});
    }
    //link.id = nodeByName(link.id);
    //link.broadcaster_id = nodeByName(link.broadcaster_id);
  });

  console.log(links);
  // Extract the array of nodes from the map by name.
  //key/value pair is the context?
  // var nodes = d3.values(nodesByName);
  // console.log(nodes);
  // // Create the link lines.
  // var link = svg.selectAll(".link")
  //     .data(links)
  //   .enter().append("line")
  //     .attr("class", "link")
  //     .style("stroke", function(d){
  //       if(d.source.name[0]=='P') return 'black';
  //       else return 'blue';
  //     });
  // // Create the node circles.
  // var node = svg.selectAll(".node")
  //     .data(nodes)
  //   .enter().append("g")
  //     .attr("class", "node")
  //     .call(force.drag);

  // node.append("circle").attr("r", 4.5)
  //   .attr('fill', function(d)
  //     {
  //       if(d.name[0]=='P') return 'black';
  //       else return 'blue';
  //     });

  //  node.append("text")
  //     //.attr("dx", 12)
  //     // .attr("dy", ".35em")
  //     .attr('stroke', 'black')
  //     .text(function(d) { return d.name });

  // // Start the force layout.
  // force
  //     .nodes(nodes)
  //     .links(links)
  //     .on("tick", tick)
  //     .linkDistance(20)
  //     .charge(-50)
  //     .start();

  // function tick() {
  //   link.attr("x1", function(d) { return d.source.x; })
  //       .attr("y1", function(d) { return d.source.y; })
  //       .attr("x2", function(d) { return d.target.x; })
  //       .attr("y2", function(d) { return d.target.y; });
  //   node.attr("cx", function(d) { return d.x; })
  //       .attr("cy", function(d) { return d.y; });

  //   node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  // }
  //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  

  function nodeByName(name) {
    return nodesByName[name] || (nodesByName[name] = {name: name});
  }



  function nodeByNode(node, name) {
    //console.log(nodesByName[name]);
    if(!nodesByName[name]) nodesByName[name] = {name: name, node};
    return nodesByName[name];
    
  }
});












d3.csv("data/audio_pieces_mod.csv", function(error, reccs) {
  if (error) throw error;

  //console.log(links);

  reccs.forEach(function(recc) {
    //the method removes redundancy
    //link.source = nodeByName(link.source);
    //link.target = nodeByName(link.target);

    var noTarget = true;
    if(recc.producer_id.length>0) noTarget = false;
    if(recc.producer_2_id.length>0) noTarget = false;
    if(recc.producer_3_id.length>0) noTarget = false;
    
    if(!noTarget)
    {
      var s= nodeByName(recc.id);
      var t = nodeByName(recc.producer_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:1});

      t = nodeByName(recc.producer_2_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:1});

      t = nodeByName(recc.producer_3_id);
      if(t.name.length>0)links.push({source: s, target: t, weight:1});
    }

  });

  console.log(links);
  // Extract the array of nodes from the map by name.
  //key/value pair is the context?
  var nodes = d3.values(nodesByName);
  console.log(nodes);
  // Create the link lines.
  var link = svg.selectAll(".link")
      .data(links)
    .enter().append("line")
      .attr("class", "link")
      .style("stroke", function(d){
        if(d.source.name[0]=='P') return 'black';
        else return 'red';
      });
  // Create the node circles.
  var node = svg.selectAll(".node")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node")
      .call(force.drag);

  node.append("circle").attr("r", 4.5)
    .attr('fill', function(d)
      {
        if(d.name[0]=='P') return 'black';
        else return '#FFFFFF00';
      })
    .attr('stroke', function(d)
      {
        if(d.name[0]=='P') return '#FFFFFF00';
        else return 'black';
      })
    .on("click", function(d){
        console.log(d.name.length);
      }
      );

   node.append("text")
      .style("font-size", 10)
      .attr('stroke', 'black')
      .text(function(d) { 
        console.log(d);
        return d.name
      });

  // Start the force layout.
  force
      .nodes(nodes)
      .links(links)
      .on("tick", tick)
      .linkDistance(5)
      .charge(-60)
      .start()
      .linkStrength(function(link)
        {
          return link.weight;
        });

  function tick() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  }
  //node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  

  function nodeByName(name) {
    return nodesByName[name] || (nodesByName[name] = {name: name});
  }

  function nodeByNode(node, name) {
    //console.log(nodesByName[name]);
    if(!nodesByName[name]) nodesByName[name] = {name: name, node};
    return nodesByName[name];
    
  }
});

//add zoom capabilities 
var zoom_handler = d3.zoom()
    .on("zoom", zoom_actions);

zoom_handler(svg); 
</script>